Crazypadel Project Dump
========================================


========================================
DJANGO SETTINGS
========================================

ABSOLUTE_URL_OVERRIDES: {}
ADMINS: []
ALLOWED_HOSTS: []
APPEND_SLASH: True
AUTHENTICATION_BACKENDS: ['django.contrib.auth.backends.ModelBackend']
AUTH_PASSWORD_VALIDATORS: [{'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'}, {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', 'OPTIONS': {'min_length': 8}}, {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'}, {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'}]
AUTH_USER_MODEL: accounts.User
BASE_DIR: /Users/dariovenanzi/Repository/crazypadel
CACHES: {'default': {'BACKEND': 'django.core.cache.backends.locmem.LocMemCache'}}
CACHE_MIDDLEWARE_ALIAS: default
CACHE_MIDDLEWARE_KEY_PREFIX: 
CACHE_MIDDLEWARE_SECONDS: 600
CSRF_COOKIE_AGE: 31449600
CSRF_COOKIE_DOMAIN: None
CSRF_COOKIE_HTTPONLY: False
CSRF_COOKIE_NAME: csrftoken
CSRF_COOKIE_PATH: /
CSRF_COOKIE_SAMESITE: Lax
CSRF_COOKIE_SECURE: False
CSRF_FAILURE_VIEW: django.views.csrf.csrf_failure
CSRF_HEADER_NAME: HTTP_X_CSRFTOKEN
CSRF_TRUSTED_ORIGINS: []
CSRF_USE_SESSIONS: False
DATABASES: {'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': PosixPath('/Users/dariovenanzi/Repository/crazypadel/db.sqlite3')}}
DATABASE_ROUTERS: []
DATA_UPLOAD_MAX_MEMORY_SIZE: 2621440
DATA_UPLOAD_MAX_NUMBER_FIELDS: 1000
DATA_UPLOAD_MAX_NUMBER_FILES: 100
DATETIME_FORMAT: N j, Y, P
DATETIME_INPUT_FORMATS: ['%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M', '%m/%d/%Y %H:%M:%S', '%m/%d/%Y %H:%M:%S.%f', '%m/%d/%Y %H:%M', '%m/%d/%y %H:%M:%S', '%m/%d/%y %H:%M:%S.%f', '%m/%d/%y %H:%M']
DATE_FORMAT: N j, Y
DATE_INPUT_FORMATS: ['%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y', '%b %d %Y', '%b %d, %Y', '%d %b %Y', '%d %b, %Y', '%B %d %Y', '%B %d, %Y', '%d %B %Y', '%d %B, %Y']
DEBUG: True
DEBUG_PROPAGATE_EXCEPTIONS: False
DECIMAL_SEPARATOR: .
DEFAULT_AUTO_FIELD: django.db.models.BigAutoField
DEFAULT_CHARSET: utf-8
DEFAULT_EXCEPTION_REPORTER: django.views.debug.ExceptionReporter
DEFAULT_EXCEPTION_REPORTER_FILTER: django.views.debug.SafeExceptionReporterFilter
DEFAULT_FROM_EMAIL: webmaster@localhost
DEFAULT_INDEX_TABLESPACE: 
DEFAULT_TABLESPACE: 
DISALLOWED_USER_AGENTS: []
EMAIL_BACKEND: django.core.mail.backends.smtp.EmailBackend
EMAIL_HOST: localhost
EMAIL_HOST_PASSWORD: 
EMAIL_HOST_USER: 
EMAIL_PORT: 25
EMAIL_SSL_CERTFILE: None
EMAIL_SSL_KEYFILE: None
EMAIL_SUBJECT_PREFIX: [Django] 
EMAIL_TIMEOUT: None
EMAIL_USE_LOCALTIME: False
EMAIL_USE_SSL: False
EMAIL_USE_TLS: False
FILE_UPLOAD_DIRECTORY_PERMISSIONS: None
FILE_UPLOAD_HANDLERS: ['django.core.files.uploadhandler.MemoryFileUploadHandler', 'django.core.files.uploadhandler.TemporaryFileUploadHandler']
FILE_UPLOAD_MAX_MEMORY_SIZE: 2621440
FILE_UPLOAD_PERMISSIONS: 420
FILE_UPLOAD_TEMP_DIR: None
FIRST_DAY_OF_WEEK: 0
FIXTURE_DIRS: []
FORCE_SCRIPT_NAME: None
FORMAT_MODULE_PATH: None
FORMS_URLFIELD_ASSUME_HTTPS: False
FORM_RENDERER: django.forms.renderers.DjangoTemplates
IGNORABLE_404_URLS: []
INSTALLED_APPS: ['django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'accounts', 'leagues']
INTERNAL_IPS: []
LANGUAGES: [('af', 'Afrikaans'), ('ar', 'Arabic'), ('ar-dz', 'Algerian Arabic'), ('ast', 'Asturian'), ('az', 'Azerbaijani'), ('bg', 'Bulgarian'), ('be', 'Belarusian'), ('bn', 'Bengali'), ('br', 'Breton'), ('bs', 'Bosnian'), ('ca', 'Catalan'), ('ckb', 'Central Kurdish (Sorani)'), ('cs', 'Czech'), ('cy', 'Welsh'), ('da', 'Danish'), ('de', 'German'), ('dsb', 'Lower Sorbian'), ('el', 'Greek'), ('en', 'English'), ('en-au', 'Australian English'), ('en-gb', 'British English'), ('eo', 'Esperanto'), ('es', 'Spanish'), ('es-ar', 'Argentinian Spanish'), ('es-co', 'Colombian Spanish'), ('es-mx', 'Mexican Spanish'), ('es-ni', 'Nicaraguan Spanish'), ('es-ve', 'Venezuelan Spanish'), ('et', 'Estonian'), ('eu', 'Basque'), ('fa', 'Persian'), ('fi', 'Finnish'), ('fr', 'French'), ('fy', 'Frisian'), ('ga', 'Irish'), ('gd', 'Scottish Gaelic'), ('gl', 'Galician'), ('he', 'Hebrew'), ('hi', 'Hindi'), ('hr', 'Croatian'), ('hsb', 'Upper Sorbian'), ('hu', 'Hungarian'), ('hy', 'Armenian'), ('ia', 'Interlingua'), ('id', 'Indonesian'), ('ig', 'Igbo'), ('io', 'Ido'), ('is', 'Icelandic'), ('it', 'Italian'), ('ja', 'Japanese'), ('ka', 'Georgian'), ('kab', 'Kabyle'), ('kk', 'Kazakh'), ('km', 'Khmer'), ('kn', 'Kannada'), ('ko', 'Korean'), ('ky', 'Kyrgyz'), ('lb', 'Luxembourgish'), ('lt', 'Lithuanian'), ('lv', 'Latvian'), ('mk', 'Macedonian'), ('ml', 'Malayalam'), ('mn', 'Mongolian'), ('mr', 'Marathi'), ('ms', 'Malay'), ('my', 'Burmese'), ('nb', 'Norwegian Bokmål'), ('ne', 'Nepali'), ('nl', 'Dutch'), ('nn', 'Norwegian Nynorsk'), ('os', 'Ossetic'), ('pa', 'Punjabi'), ('pl', 'Polish'), ('pt', 'Portuguese'), ('pt-br', 'Brazilian Portuguese'), ('ro', 'Romanian'), ('ru', 'Russian'), ('sk', 'Slovak'), ('sl', 'Slovenian'), ('sq', 'Albanian'), ('sr', 'Serbian'), ('sr-latn', 'Serbian Latin'), ('sv', 'Swedish'), ('sw', 'Swahili'), ('ta', 'Tamil'), ('te', 'Telugu'), ('tg', 'Tajik'), ('th', 'Thai'), ('tk', 'Turkmen'), ('tr', 'Turkish'), ('tt', 'Tatar'), ('udm', 'Udmurt'), ('ug', 'Uyghur'), ('uk', 'Ukrainian'), ('ur', 'Urdu'), ('uz', 'Uzbek'), ('vi', 'Vietnamese'), ('zh-hans', 'Simplified Chinese'), ('zh-hant', 'Traditional Chinese')]
LANGUAGES_BIDI: ['he', 'ar', 'ar-dz', 'ckb', 'fa', 'ug', 'ur']
LANGUAGE_CODE: it-it
LANGUAGE_COOKIE_AGE: None
LANGUAGE_COOKIE_DOMAIN: None
LANGUAGE_COOKIE_HTTPONLY: False
LANGUAGE_COOKIE_NAME: django_language
LANGUAGE_COOKIE_PATH: /
LANGUAGE_COOKIE_SAMESITE: None
LANGUAGE_COOKIE_SECURE: False
LOCALE_PATHS: []
LOGGING: {}
LOGGING_CONFIG: logging.config.dictConfig
LOGIN_REDIRECT_URL: /leagues/
LOGIN_URL: /accounts/login/
LOGOUT_REDIRECT_URL: /
MANAGERS: []
MEDIA_ROOT: 
MEDIA_URL: /
MESSAGE_STORAGE: django.contrib.messages.storage.fallback.FallbackStorage
MIDDLEWARE: ['django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware']
MIGRATION_MODULES: {}
MONTH_DAY_FORMAT: F j
NUMBER_GROUPING: 0
PASSWORD_HASHERS: ['django.contrib.auth.hashers.PBKDF2PasswordHasher', 'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher', 'django.contrib.auth.hashers.Argon2PasswordHasher', 'django.contrib.auth.hashers.BCryptSHA256PasswordHasher', 'django.contrib.auth.hashers.ScryptPasswordHasher']
PASSWORD_RESET_TIMEOUT: 259200
PREPEND_WWW: False
ROOT_URLCONF: crazypadel.urls
SECRET_KEY: django-insecure-xyz123
SECRET_KEY_FALLBACKS: []
SECURE_CONTENT_TYPE_NOSNIFF: True
SECURE_CROSS_ORIGIN_OPENER_POLICY: same-origin
SECURE_HSTS_INCLUDE_SUBDOMAINS: False
SECURE_HSTS_PRELOAD: False
SECURE_HSTS_SECONDS: 0
SECURE_PROXY_SSL_HEADER: None
SECURE_REDIRECT_EXEMPT: []
SECURE_REFERRER_POLICY: same-origin
SECURE_SSL_HOST: None
SECURE_SSL_REDIRECT: False
SERVER_EMAIL: root@localhost
SESSION_CACHE_ALIAS: default
SESSION_COOKIE_AGE: 1209600
SESSION_COOKIE_DOMAIN: None
SESSION_COOKIE_HTTPONLY: True
SESSION_COOKIE_NAME: sessionid
SESSION_COOKIE_PATH: /
SESSION_COOKIE_SAMESITE: Lax
SESSION_COOKIE_SECURE: False
SESSION_ENGINE: django.contrib.sessions.backends.db
SESSION_EXPIRE_AT_BROWSER_CLOSE: False
SESSION_FILE_PATH: None
SESSION_SAVE_EVERY_REQUEST: False
SESSION_SERIALIZER: django.contrib.sessions.serializers.JSONSerializer
SETTINGS_MODULE: crazypadel.settings
SHORT_DATETIME_FORMAT: m/d/Y P
SHORT_DATE_FORMAT: m/d/Y
SIGNING_BACKEND: django.core.signing.TimestampSigner
SILENCED_SYSTEM_CHECKS: []
STATICFILES_DIRS: ['/Users/dariovenanzi/Repository/crazypadel/static']
STATICFILES_FINDERS: ['django.contrib.staticfiles.finders.FileSystemFinder', 'django.contrib.staticfiles.finders.AppDirectoriesFinder']
STATIC_ROOT: /Users/dariovenanzi/Repository/crazypadel/staticfiles
STATIC_URL: /static/
STORAGES: {'default': {'BACKEND': 'django.core.files.storage.FileSystemStorage'}, 'staticfiles': {'BACKEND': 'django.contrib.staticfiles.storage.StaticFilesStorage'}}
TEMPLATES: [{'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': ['/Users/dariovenanzi/Repository/crazypadel/templates'], 'APP_DIRS': True, 'OPTIONS': {'context_processors': ['django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages']}}]
TEST_NON_SERIALIZED_APPS: []
TEST_RUNNER: django.test.runner.DiscoverRunner
THOUSAND_SEPARATOR: ,
TIME_FORMAT: P
TIME_INPUT_FORMATS: ['%H:%M:%S', '%H:%M:%S.%f', '%H:%M']
TIME_ZONE: Europe/Rome
USE_I18N: True
USE_THOUSAND_SEPARATOR: False
USE_TZ: True
USE_X_FORWARDED_HOST: False
USE_X_FORWARDED_PORT: False
WSGI_APPLICATION: crazypadel.wsgi.application
X_FRAME_OPTIONS: DENY
YEAR_MONTH_FORMAT: F Y

========================================
APP: accounts
========================================


-- accounts/models.py --

from django.contrib.auth.models import AbstractUser
from django.db import models


class User(AbstractUser):
    """
    Estensione del modello utente di Django.
    Non richiediamo email, solo username e password.
    """
    # Il campo email è opzionale
    email = models.EmailField(blank=True, null=True)
    
    # Disabilita l'uso dell'email per validazione
    EMAIL_FIELD = None
    REQUIRED_FIELDS = []  # Rimuoviamo 'email' dalla lista dei campi richiesti
    
    class Meta:
        verbose_name = 'Utente'
        verbose_name_plural = 'Utenti'
    
    def __str__(self):
        return self.username
    
    def is_league_president(self, league):
        """Controlla se l'utente è presidente della lega specificata"""
        return hasattr(league, 'president') and league.president == self

-- accounts/__init__.py --



-- accounts/apps.py --

from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'


-- accounts/forms.py --

from django import forms
from django.contrib.auth.forms import UserCreationForm, UserChangeForm
from .models import User

class UserRegisterForm(UserCreationForm):
    """Form per registrare un nuovo utente"""
    class Meta:
        model = User
        fields = ['username', 'password1', 'password2', 'first_name', 'last_name']
        
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Rendi opzionali i campi first_name e last_name
        self.fields['first_name'].required = False
        self.fields['last_name'].required = False
        
        # Personalizza i messaggi di aiuto
        self.fields['username'].help_text = 'Richiesto. 150 caratteri o meno. Solo lettere, numeri e @/./+/-/_.'
        self.fields['password1'].help_text = 'La password deve contenere almeno 8 caratteri.'

class UserUpdateForm(forms.ModelForm):
    """Form per aggiornare i dati del profilo utente"""
    class Meta:
        model = User
        fields = ['username', 'first_name', 'last_name']

-- accounts/admin.py --

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import User

@admin.register(User)
class CustomUserAdmin(UserAdmin):
    list_display = ('username', 'is_staff', 'is_active', 'date_joined')
    fieldsets = (
        (None, {'fields': ('username', 'password')}),
        ('Informazioni personali', {'fields': ('first_name', 'last_name', 'email')}),
        ('Permessi', {
            'fields': ('is_active', 'is_staff', 'is_superuser', 'groups', 'user_permissions'),
        }),
        ('Date importanti', {'fields': ('last_login', 'date_joined')}),
    )
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'password1', 'password2'),
        }),
    )
    search_fields = ('username', 'first_name', 'last_name')
    ordering = ('username',)

-- accounts/tests.py --

from django.test import TestCase

# Create your tests here.


-- accounts/urls.py --

from django.urls import path
from django.contrib.auth import views as auth_views
from . import views

app_name = 'accounts'

urlpatterns = [
    path('login/', auth_views.LoginView.as_view(template_name='accounts/login.html'), name='login'),
    path('register/', views.register, name='register'),
    path('profile/', views.profile, name='profile'),
    path('logout/', views.logout_view, name='logout'),
]

-- accounts/views.py --

from django.shortcuts import render, redirect
from django.contrib.auth import login
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import User
from .forms import UserRegisterForm, UserUpdateForm
from django.contrib.auth import logout
from django.shortcuts import redirect

def logout_view(request):
    logout(request)
    return redirect('accounts:login')

def register(request):
    """Vista per la registrazione di un nuovo utente"""
    if request.method == 'POST':
        form = UserRegisterForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            messages.success(request, f'Account creato con successo!')
            return redirect('leagues:list')
    else:
        form = UserRegisterForm()
    return render(request, 'accounts/register.html', {'form': form})

@login_required
def profile(request):
    """Vista per visualizzare e modificare il profilo utente"""
    from django.db.models import Count, Q, Sum, Case, When, IntegerField, F
    from django.utils import timezone
    import datetime
    
    if request.method == 'POST':
        form = UserUpdateForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
            messages.success(request, f'Il tuo profilo è stato aggiornato!')
            return redirect('accounts:profile')
    else:
        form = UserUpdateForm(instance=request.user)
    
    # Statistiche di base
    leagues_count = request.user.leagues.count()
    
    # Statistiche partite
    user_matches = request.user.matches.all()
    total_matches = user_matches.count()
    
    # Calcola vittorie
    wins_count = 0
    losses_count = 0
    sets_won = 0
    total_sets = 0
    
    # Statistiche partner e avversari
    teammates = {}
    opponents = {}
    
    # Analisi partite
    for match_player in user_matches.select_related('match'):
        match = match_player.match
        team = match_player.team
        
        # Calcola set totali
        total_sets += match.team1_sets + match.team2_sets
        
        # Calcola vittorie/sconfitte
        if team == 1:
            sets_won += match.team1_sets
            if match.team1_sets > match.team2_sets:
                wins_count += 1
            elif match.team1_sets < match.team2_sets:
                losses_count += 1
        else:
            sets_won += match.team2_sets
            if match.team2_sets > match.team1_sets:
                wins_count += 1
            elif match.team2_sets < match.team1_sets:
                losses_count += 1
        
        # Analisi compagni di squadra
        teammates_in_match = match.players.filter(team=team).exclude(player=request.user)
        for teammate in teammates_in_match:
            if teammate.player_id not in teammates:
                teammates[teammate.player_id] = {'player': teammate.player, 'matches': 0, 'wins': 0}
            
            teammates[teammate.player_id]['matches'] += 1
            if (team == 1 and match.team1_sets > match.team2_sets) or (team == 2 and match.team2_sets > match.team1_sets):
                teammates[teammate.player_id]['wins'] += 1
        
        # Analisi avversari
        opponents_in_match = match.players.filter(~Q(team=team))
        for opponent in opponents_in_match:
            if opponent.player_id not in opponents:
                opponents[opponent.player_id] = {'player': opponent.player, 'matches': 0, 'losses': 0}
            
            opponents[opponent.player_id]['matches'] += 1
            if (team == 1 and match.team1_sets < match.team2_sets) or (team == 2 and match.team2_sets < match.team1_sets):
                opponents[opponent.player_id]['losses'] += 1
    
    # Calcola percentuale vittorie
    win_percentage = int((wins_count / total_matches) * 100) if total_matches > 0 else 0
    avg_sets_per_match = round(total_sets / total_matches, 1) if total_matches > 0 else 0
    
    # Trova compagno preferito
    favorite_partner = None
    partner_stats = None
    if teammates:
        best_teammate_id = max(teammates.items(), key=lambda x: x[1]['wins'])
        favorite_partner = best_teammate_id[1]['player']
        partner_stats = {
            'matches': best_teammate_id[1]['matches'],
            'wins': best_teammate_id[1]['wins'],
            'win_rate': int((best_teammate_id[1]['wins'] / best_teammate_id[1]['matches']) * 100) if best_teammate_id[1]['matches'] > 0 else 0
        }
    
    # Trova avversario più difficile
    toughest_opponent = None
    opponent_stats = None
    if opponents:
        worst_opponent_id = max(opponents.items(), key=lambda x: x[1]['losses'])
        toughest_opponent = worst_opponent_id[1]['player']
        opponent_stats = {
            'matches': worst_opponent_id[1]['matches'],
            'losses': worst_opponent_id[1]['losses'],
            'loss_rate': int((worst_opponent_id[1]['losses'] / worst_opponent_id[1]['matches']) * 100) if worst_opponent_id[1]['matches'] > 0 else 0
        }
    
    # Esempio di dati per trend di performance
    performance_trend = None
    if total_matches > 5:
        # Questa è solo una simulazione, in un'app reale andrebbero calcolati dai dati effettivi
        performance_trend = [
            {'month_short': 'Gen', 'month_name': 'Gennaio', 'wins': 3, 'matches': 5, 'win_rate': 60},
            {'month_short': 'Feb', 'month_name': 'Febbraio', 'wins': 4, 'matches': 6, 'win_rate': 67},
            {'month_short': 'Mar', 'month_name': 'Marzo', 'wins': 2, 'matches': 5, 'win_rate': 40},
            {'month_short': 'Apr', 'month_name': 'Aprile', 'wins': 5, 'matches': 7, 'win_rate': 71},
            {'month_short': 'Mag', 'month_name': 'Maggio', 'wins': 3, 'matches': 4, 'win_rate': 75},
            {'month_short': 'Giu', 'month_name': 'Giugno', 'wins': 2, 'matches': 3, 'win_rate': 67},
        ]
    
    # Esempio per campo fortunato
    lucky_court = None
    court_stats = None
    # In una vera app, questi dati verrebbero calcolati basandosi sui campi effettivi
    if total_matches > 3:
        lucky_court = "Centro Sportivo XYZ - Campo 3"
        court_stats = {
            'matches': 8,
            'wins': 6,
            'win_rate': 75
        }
    
    # Recupera le partite recenti
    recent_matches = []
    if total_matches > 0:
        # Otteniamo le partite, non i MatchPlayer
        match_ids = user_matches.values_list('match_id', flat=True)
        from leagues.models import Match
        recent_matches = Match.objects.filter(id__in=match_ids).order_by('-match_date')[:5]

    # Calcola striscia di vittorie consecutive
    winning_streak = 0
    if recent_matches:
        for match in recent_matches:
            # Trova il match player relativo all'utente corrente
            user_mp = match.players.filter(player=request.user).first()
            if user_mp:
                team = user_mp.team
                if (team == 1 and match.team1_sets > match.team2_sets) or (team == 2 and match.team2_sets > match.team1_sets):
                    winning_streak += 1
                else:
                    # Se ha perso, interrompiamo il conteggio
                    break
            else:
                break
    
    context = {
        'form': form,
        'leagues_count': leagues_count,
        'total_matches': total_matches,
        'total_wins': wins_count,
        'total_losses': losses_count,
        'win_percentage': win_percentage,
        'total_sets': total_sets,
        'sets_won': sets_won,
        'avg_sets_per_match': avg_sets_per_match,
        'favorite_partner': favorite_partner,
        'partner_stats': partner_stats,
        'toughest_opponent': toughest_opponent,
        'opponent_stats': opponent_stats,
        'performance_trend': performance_trend,
        'recent_matches': recent_matches,
        'winning_streak': winning_streak,
    }
    
    return render(request, 'accounts/profile.html', context)



-- accounts/migrations/__init__.py --



-- accounts/migrations/0001_initial.py --

# Generated by Django 5.1.6 on 2025-02-19 10:04

import django.contrib.auth.models
import django.contrib.auth.validators
import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('auth', '0012_alter_user_first_name_max_length'),
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('password', models.CharField(max_length=128, verbose_name='password')),
                ('last_login', models.DateTimeField(blank=True, null=True, verbose_name='last login')),
                ('is_superuser', models.BooleanField(default=False, help_text='Designates that this user has all permissions without explicitly assigning them.', verbose_name='superuser status')),
                ('username', models.CharField(error_messages={'unique': 'A user with that username already exists.'}, help_text='Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.', max_length=150, unique=True, validators=[django.contrib.auth.validators.UnicodeUsernameValidator()], verbose_name='username')),
                ('first_name', models.CharField(blank=True, max_length=150, verbose_name='first name')),
                ('last_name', models.CharField(blank=True, max_length=150, verbose_name='last name')),
                ('is_staff', models.BooleanField(default=False, help_text='Designates whether the user can log into this admin site.', verbose_name='staff status')),
                ('is_active', models.BooleanField(default=True, help_text='Designates whether this user should be treated as active. Unselect this instead of deleting accounts.', verbose_name='active')),
                ('date_joined', models.DateTimeField(default=django.utils.timezone.now, verbose_name='date joined')),
                ('email', models.EmailField(blank=True, max_length=254, null=True)),
                ('groups', models.ManyToManyField(blank=True, help_text='The groups this user belongs to. A user will get all permissions granted to each of their groups.', related_name='user_set', related_query_name='user', to='auth.group', verbose_name='groups')),
                ('user_permissions', models.ManyToManyField(blank=True, help_text='Specific permissions for this user.', related_name='user_set', related_query_name='user', to='auth.permission', verbose_name='user permissions')),
            ],
            options={
                'verbose_name': 'Utente',
                'verbose_name_plural': 'Utenti',
            },
            managers=[
                ('objects', django.contrib.auth.models.UserManager()),
            ],
        ),
    ]


========================================
APP: leagues
========================================


-- leagues/models.py --

import string
import random
from django.db import models
from django.db.models import Q
from django.utils import timezone
from django.conf import settings

User = settings.AUTH_USER_MODEL


def generate_league_code():
    """Genera un codice alfanumerico univoco per la lega"""
    chars = string.ascii_uppercase + string.digits
    while True:
        code = ''.join(random.choice(chars) for _ in range(6))
        if not League.objects.filter(join_code=code).exists():
            return code


class League(models.Model):
    """Modello per le leghe di padel"""
    name = models.CharField(max_length=100, verbose_name="Nome lega")
    created_at = models.DateTimeField(auto_now_add=True)
    president = models.ForeignKey(
        User, 
        on_delete=models.PROTECT,
        related_name='presided_leagues',
        verbose_name="Presidente"
    )
    join_code = models.CharField(
        max_length=6,
        unique=True,
        default=generate_league_code,
        verbose_name="Codice di accesso"
    )
    players = models.ManyToManyField(
        User,
        through='Membership',
        related_name='leagues',
        verbose_name="Giocatori"
    )
    
    class Meta:
        verbose_name = "Lega"
        verbose_name_plural = "Leghe"
        ordering = ['name']
    
    def __str__(self):
        return self.name
    
    def get_league_standings(self):
        """Calcola e restituisce la classifica dei giocatori nella lega"""
        # Membri della lega
        members = self.membership_set.all()
        standings = []
        
        for membership in members:
            player = membership.player
            
            # Statistiche partite
            player_matches = MatchPlayer.objects.filter(
                player=player,
                match__league=self
            )
            matches_played = player_matches.count()
            
            if matches_played == 0:
                continue
                
            # Calcola vittorie, sconfitte e set vinti
            wins = 0
            sets_won = 0
            
            for mp in player_matches:
                match = mp.match
                # Determina se il giocatore ha vinto
                if (mp.team == 1 and match.team1_sets > match.team2_sets) or \
                   (mp.team == 2 and match.team2_sets > match.team1_sets):
                    wins += 1
                
                # Calcola set vinti
                if mp.team == 1:
                    sets_won += match.team1_sets
                else:
                    sets_won += match.team2_sets
            
            losses = matches_played - wins
            
            # Calcola punti (3 per vittoria)
            points = wins * 3
            
            standings.append({
                'player': player,
                'matches_played': matches_played,
                'wins': wins,
                'losses': losses,
                'sets_won': sets_won,
                'points': points
            })
        
        # Ordina per punti, vittorie, set vinti
        standings.sort(
            key=lambda x: (x['points'], x['wins'], x['sets_won']),
            reverse=True
        )
        
        return standings


class Membership(models.Model):
    """Modello per l'appartenenza di un utente a una lega"""
    player = models.ForeignKey(User, on_delete=models.CASCADE)
    league = models.ForeignKey(League, on_delete=models.CASCADE)
    joined_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        verbose_name = "Iscrizione"
        verbose_name_plural = "Iscrizioni"
        unique_together = ['player', 'league']
    
    def __str__(self):
        return f"{self.player} - {self.league.name}"


class Match(models.Model):
    """Modello per le partite di padel"""
    league = models.ForeignKey(
        League,
        on_delete=models.CASCADE,
        related_name='matches',
        verbose_name="Lega"
    )
    match_date = models.DateField(default=timezone.now, verbose_name="Data partita")
    team1_sets = models.PositiveSmallIntegerField(default=0, verbose_name="Set Squadra 1")
    team2_sets = models.PositiveSmallIntegerField(default=0, verbose_name="Set Squadra 2")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = "Partita"
        verbose_name_plural = "Partite"
        ordering = ['-match_date', '-created_at']
    
    def __str__(self):
        team1_players = self.players.filter(team=1)
        team2_players = self.players.filter(team=2)
        
        if not team1_players.exists() or not team2_players.exists():
            return f"Partita {self.id} ({self.match_date})"
            
        team1_str = " / ".join([str(mp.player) for mp in team1_players])
        team2_str = " / ".join([str(mp.player) for mp in team2_players])
        
        return f"{team1_str} {self.team1_sets}-{self.team2_sets} {team2_str} ({self.match_date})"
    
    @property
    def winner_team(self):
        """Restituisce il numero della squadra vincitrice (1 o 2) o None se pareggio"""
        if self.team1_sets > self.team2_sets:
            return 1
        elif self.team2_sets > self.team1_sets:
            return 2
        return None


class MatchPlayer(models.Model):
    """Relazione tra giocatori e partite"""
    TEAM_CHOICES = [
        (1, 'Squadra 1'),
        (2, 'Squadra 2'),
    ]
    
    match = models.ForeignKey(
        Match,
        on_delete=models.CASCADE,
        related_name='players'
    )
    player = models.ForeignKey(
        User,
        on_delete=models.CASCADE,
        related_name='matches'
    )
    team = models.PositiveSmallIntegerField(choices=TEAM_CHOICES)
    
    class Meta:
        verbose_name = "Giocatore partita"
        verbose_name_plural = "Giocatori partita"
        unique_together = ['match', 'player']
    
    def __str__(self):
        return f"{self.player} - {self.get_team_display()}"

-- leagues/__init__.py --



-- leagues/apps.py --

from django.apps import AppConfig


class LeaguesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'leagues'


-- leagues/forms.py --

from django import forms
from .models import League, Match

class LeagueForm(forms.ModelForm):
    """Form per creare una nuova lega"""
    class Meta:
        model = League
        fields = ['name']
        labels = {
            'name': 'Nome della lega',
        }

class JoinLeagueForm(forms.Form):
    """Form per unirsi a una lega tramite codice"""
    join_code = forms.CharField(
        max_length=6, 
        min_length=6,
        label='Codice di accesso',
        help_text='Inserisci il codice di 6 caratteri fornito dal presidente della lega'
    )
    
    def clean_join_code(self):
        code = self.cleaned_data['join_code'].upper()
        return code

class MatchForm(forms.ModelForm):
    """Form per creare/modificare una partita"""
    team1_player1 = forms.ModelChoiceField(queryset=None, label='Giocatore 1 (squadra 1)')
    team1_player2 = forms.ModelChoiceField(queryset=None, label='Giocatore 2 (squadra 1)')
    team2_player1 = forms.ModelChoiceField(queryset=None, label='Giocatore 1 (squadra 2)')
    team2_player2 = forms.ModelChoiceField(queryset=None, label='Giocatore 2 (squadra 2)')
    
    class Meta:
        model = Match
        fields = ['match_date', 'team1_sets', 'team2_sets']
        labels = {
            'match_date': 'Data della partita',
            'team1_sets': 'Set vinti dalla squadra 1',
            'team2_sets': 'Set vinti dalla squadra 2',
        }
        widgets = {
            'match_date': forms.DateInput(attrs={'type': 'date'}),
        }
    
    def __init__(self, *args, **kwargs):
        # Estrai la lega dal kwargs
        self.league = kwargs.pop('league', None)
        super().__init__(*args, **kwargs)
        
        if self.league:
            # Imposta i queryset con i membri della lega
            members = self.league.players.all()
            self.fields['team1_player1'].queryset = members
            self.fields['team1_player2'].queryset = members
            self.fields['team2_player1'].queryset = members
            self.fields['team2_player2'].queryset = members
    
    def clean(self):
        cleaned_data = super().clean()
        
        # Controllo che i 4 giocatori siano diversi
        players = [
            cleaned_data.get('team1_player1'),
            cleaned_data.get('team1_player2'),
            cleaned_data.get('team2_player1'),
            cleaned_data.get('team2_player2'),
        ]
        
        if len(set(filter(None, players))) != 4:
            raise forms.ValidationError(
                "Tutti i giocatori devono essere diversi. Ogni partita deve avere esattamente 4 giocatori distinti."
            )
        
        return cleaned_data

-- leagues/admin.py --

from django.contrib import admin
from .models import League, Membership, Match, MatchPlayer

class MembershipInline(admin.TabularInline):
    model = Membership
    extra = 1

class MatchPlayerInline(admin.TabularInline):
    model = MatchPlayer
    extra = 4
    max_num = 4

@admin.register(League)
class LeagueAdmin(admin.ModelAdmin):
    list_display = ('name', 'president', 'join_code', 'created_at')
    search_fields = ('name', 'president__username')
    inlines = [MembershipInline]

@admin.register(Membership)
class MembershipAdmin(admin.ModelAdmin):
    list_display = ('player', 'league', 'joined_at')
    list_filter = ('league',)
    search_fields = ('player__username', 'league__name')

@admin.register(Match)
class MatchAdmin(admin.ModelAdmin):
    list_display = ('__str__', 'league', 'match_date', 'team1_sets', 'team2_sets')
    list_filter = ('league', 'match_date')
    date_hierarchy = 'match_date'
    inlines = [MatchPlayerInline]

@admin.register(MatchPlayer)
class MatchPlayerAdmin(admin.ModelAdmin):
    list_display = ('player', 'match', 'get_team_display')
    list_filter = ('team', 'match__league')
    search_fields = ('player__username',)

-- leagues/tests.py --

from django.test import TestCase

# Create your tests here.


-- leagues/urls.py --

from django.urls import path
from . import views

app_name = 'leagues'

urlpatterns = [
    # League management
    path('', views.league_list, name='list'),
    path('create/', views.create_league, name='create'),
    path('<int:league_id>/', views.league_detail, name='detail'),
    path('<int:league_id>/join/', views.join_league, name='join'),
    path('join-by-code/', views.join_by_code, name='join_by_code'),
    
    # Match management (questi percorsi rimangono per retrocompatibilità)
    path('<int:league_id>/matches/create/', views.create_match, name='create_match'),
    path('<int:league_id>/matches/<int:match_id>/', views.match_detail, name='match_detail'),
    path('<int:league_id>/matches/<int:match_id>/edit/', views.edit_match, name='edit_match'),
    path('<int:league_id>/matches/<int:match_id>/delete/', views.delete_match, name='delete_match'),
]

-- leagues/views.py --

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import HttpResponseForbidden
from django.utils import timezone
from .models import League, Membership, Match, MatchPlayer
from .forms import LeagueForm, JoinLeagueForm, MatchForm

def get_team_players_string(match, team_number):
    """Restituisce una stringa formattata con i nomi dei giocatori di una squadra"""
    player_names = []
    for mp in match.players.filter(team=team_number):
        player_names.append(mp.player.username)
    return " / ".join(player_names)

@login_required
def league_list(request):
    """Vista per visualizzare le leghe dell'utente"""
    user_leagues = request.user.leagues.all()
    return render(request, 'leagues/league_list.html', {'leagues': user_leagues})

@login_required
def create_league(request):
    """Vista per creare una nuova lega"""
    if request.method == 'POST':
        form = LeagueForm(request.POST)
        if form.is_valid():
            league = form.save(commit=False)
            league.president = request.user
            league.save()
            
            # Aggiungi anche il presidente come membro
            Membership.objects.create(player=request.user, league=league)
            
            messages.success(request, f'Lega "{league.name}" creata con successo!')
            return redirect('leagues:detail', league_id=league.id)
    else:
        form = LeagueForm()
    
    return render(request, 'leagues/create_league.html', {'form': form})

@login_required
def league_detail(request, league_id):
    """Vista unificata per i dettagli di una lega, classifica e partite"""
    league = get_object_or_404(League, id=league_id)
    
    # Verifica che l'utente sia membro della lega
    if not league.players.filter(id=request.user.id).exists():
        return HttpResponseForbidden("Non sei membro di questa lega")
    
    # Ottieni tutte le partite
    matches = league.matches.all().order_by('-match_date', '-created_at')
    
    # Ottieni le ultime 5 partite
    recent_matches = matches[:5]
    
    # Prepara le stringhe dei giocatori per ogni partita
    for match in matches:
        match.team1_players_str = get_team_players_string(match, 1)
        match.team2_players_str = get_team_players_string(match, 2)
    
    for match in recent_matches:
        match.team1_players_str = get_team_players_string(match, 1)
        match.team2_players_str = get_team_players_string(match, 2)
    
    # Ottieni la classifica
    standings = league.get_league_standings()
    
    context = {
        'league': league,
        'is_president': request.user.is_league_president(league),
        'join_code': league.join_code if request.user.is_league_president(league) else None,
        'matches': matches,
        'recent_matches': recent_matches,
        'standings': standings,
        'now': timezone.now(),
        'user': request.user  # per evidenziare l'utente corrente nella classifica
    }
    return render(request, 'leagues/league_detail.html', context)

@login_required
def join_league(request, league_id):
    """Vista per unirsi a una lega (tramite ID)"""
    league = get_object_or_404(League, id=league_id)
    
    # Verifica se l'utente è già membro
    if league.players.filter(id=request.user.id).exists():
        messages.warning(request, f'Sei già membro della lega "{league.name}"')
        return redirect('leagues:detail', league_id=league.id)
    
    # Aggiungi l'utente alla lega
    Membership.objects.create(player=request.user, league=league)
    messages.success(request, f'Ti sei unito alla lega "{league.name}" con successo!')
    return redirect('leagues:detail', league_id=league.id)

@login_required
def join_by_code(request):
    """Vista per unirsi a una lega tramite codice"""
    if request.method == 'POST':
        form = JoinLeagueForm(request.POST)
        if form.is_valid():
            code = form.cleaned_data['join_code']
            try:
                league = League.objects.get(join_code=code)
                
                # Verifica se l'utente è già membro
                if league.players.filter(id=request.user.id).exists():
                    messages.warning(request, f'Sei già membro della lega "{league.name}"')
                else:
                    # Aggiungi l'utente alla lega
                    Membership.objects.create(player=request.user, league=league)
                    messages.success(request, f'Ti sei unito alla lega "{league.name}" con successo!')
                
                return redirect('leagues:detail', league_id=league.id)
            except League.DoesNotExist:
                messages.error(request, 'Codice non valido. Nessuna lega trovata.')
    else:
        form = JoinLeagueForm()
    
    return render(request, 'leagues/join_by_code.html', {'form': form})

@login_required
def league_standings(request, league_id):
    """Vista per visualizzare la classifica della lega (redirect a detail)"""
    return redirect('leagues:detail', league_id=league_id)

@login_required
def match_list(request, league_id):
    """Vista per visualizzare tutte le partite di una lega (redirect a detail)"""
    return redirect('leagues:detail', league_id=league_id)

@login_required
def match_detail(request, league_id, match_id):
    """Vista per i dettagli di una partita"""
    league = get_object_or_404(League, id=league_id)
    match = get_object_or_404(Match, id=match_id, league=league)
    
    # Verifica che l'utente sia membro della lega
    if not league.players.filter(id=request.user.id).exists():
        return HttpResponseForbidden("Non sei membro di questa lega")
    
    # Aggiungi le stringhe dei giocatori per ogni squadra
    match.team1_players_str = get_team_players_string(match, 1)
    match.team2_players_str = get_team_players_string(match, 2)
    
    context = {
        'league': league,
        'match': match,
        'is_president': request.user.is_league_president(league),
    }
    return render(request, 'leagues/match_detail.html', context)

@login_required
def create_match(request, league_id):
    """Vista per creare una nuova partita"""
    league = get_object_or_404(League, id=league_id)
    
    # Verifica che l'utente sia il presidente della lega
    if not request.user.is_league_president(league):
        return HttpResponseForbidden("Solo il presidente può creare partite")
    
    if request.method == 'POST':
        form = MatchForm(request.POST, league=league)
        if form.is_valid():
            match = form.save(commit=False)
            match.league = league
            match.save()
            
            # Salva i giocatori della partita
            team1_player1 = form.cleaned_data['team1_player1']
            team1_player2 = form.cleaned_data['team1_player2']
            team2_player1 = form.cleaned_data['team2_player1']
            team2_player2 = form.cleaned_data['team2_player2']
            
            MatchPlayer.objects.create(match=match, player=team1_player1, team=1)
            MatchPlayer.objects.create(match=match, player=team1_player2, team=1)
            MatchPlayer.objects.create(match=match, player=team2_player1, team=2)
            MatchPlayer.objects.create(match=match, player=team2_player2, team=2)
            
            messages.success(request, 'Partita creata con successo!')
            return redirect('leagues:detail', league_id=league.id)
    else:
        form = MatchForm(league=league)
    
    context = {
        'league': league,
        'form': form,
    }
    return render(request, 'leagues/create_match.html', context)

@login_required
def edit_match(request, league_id, match_id):
    """Vista per modificare una partita esistente"""
    league = get_object_or_404(League, id=league_id)
    match = get_object_or_404(Match, id=match_id, league=league)
    
    # Verifica che l'utente sia il presidente della lega
    if not request.user.is_league_president(league):
        return HttpResponseForbidden("Solo il presidente può modificare partite")
    
    if request.method == 'POST':
        form = MatchForm(request.POST, league=league, instance=match)
        if form.is_valid():
            # Aggiorna la partita
            match = form.save()
            
            # Aggiorna i giocatori
            MatchPlayer.objects.filter(match=match).delete()
            
            team1_player1 = form.cleaned_data['team1_player1']
            team1_player2 = form.cleaned_data['team1_player2']
            team2_player1 = form.cleaned_data['team2_player1']
            team2_player2 = form.cleaned_data['team2_player2']
            
            MatchPlayer.objects.create(match=match, player=team1_player1, team=1)
            MatchPlayer.objects.create(match=match, player=team1_player2, team=1)
            MatchPlayer.objects.create(match=match, player=team2_player1, team=2)
            MatchPlayer.objects.create(match=match, player=team2_player2, team=2)
            
            messages.success(request, 'Partita aggiornata con successo!')
            return redirect('leagues:detail', league_id=league.id)
    else:
        # Inizializza il form con i dati esistenti
        initial_data = {}
        
        # Ottieni i giocatori attuali
        team1_players = list(match.players.filter(team=1).values_list('player', flat=True))
        team2_players = list(match.players.filter(team=2).values_list('player', flat=True))
        
        if len(team1_players) >= 1:
            initial_data['team1_player1'] = team1_players[0]
        if len(team1_players) >= 2:
            initial_data['team1_player2'] = team1_players[1]
        if len(team2_players) >= 1:
            initial_data['team2_player1'] = team2_players[0]
        if len(team2_players) >= 2:
            initial_data['team2_player2'] = team2_players[1]
        
        form = MatchForm(league=league, instance=match, initial=initial_data)
    
    context = {
        'league': league,
        'match': match,
        'form': form,
    }
    return render(request, 'leagues/edit_match.html', context)

@login_required
def delete_match(request, league_id, match_id):
    """Vista per eliminare una partita"""
    league = get_object_or_404(League, id=league_id)
    match = get_object_or_404(Match, id=match_id, league=league)
    
    # Verifica che l'utente sia il presidente della lega
    if not request.user.is_league_president(league):
        return HttpResponseForbidden("Solo il presidente può eliminare partite")
    
    if request.method == 'POST':
        match.delete()
        messages.success(request, 'Partita eliminata con successo!')
        return redirect('leagues:detail', league_id=league.id)
    
    context = {
        'league': league,
        'match': match,
    }
    return render(request, 'leagues/delete_match.html', context)

-- leagues/migrations/__init__.py --



-- leagues/migrations/0001_initial.py --

# Generated by Django 5.1.6 on 2025-02-19 10:04

import django.db.models.deletion
import django.utils.timezone
import leagues.models
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='League',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100, verbose_name='Nome lega')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('join_code', models.CharField(default=leagues.models.generate_league_code, max_length=6, unique=True, verbose_name='Codice di accesso')),
                ('president', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='presided_leagues', to=settings.AUTH_USER_MODEL, verbose_name='Presidente')),
            ],
            options={
                'verbose_name': 'Lega',
                'verbose_name_plural': 'Leghe',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='Match',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('match_date', models.DateField(default=django.utils.timezone.now, verbose_name='Data partita')),
                ('team1_sets', models.PositiveSmallIntegerField(default=0, verbose_name='Set Squadra 1')),
                ('team2_sets', models.PositiveSmallIntegerField(default=0, verbose_name='Set Squadra 2')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('league', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='matches', to='leagues.league', verbose_name='Lega')),
            ],
            options={
                'verbose_name': 'Partita',
                'verbose_name_plural': 'Partite',
                'ordering': ['-match_date', '-created_at'],
            },
        ),
        migrations.CreateModel(
            name='Membership',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('joined_at', models.DateTimeField(auto_now_add=True)),
                ('league', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='leagues.league')),
                ('player', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Iscrizione',
                'verbose_name_plural': 'Iscrizioni',
                'unique_together': {('player', 'league')},
            },
        ),
        migrations.AddField(
            model_name='league',
            name='players',
            field=models.ManyToManyField(related_name='leagues', through='leagues.Membership', to=settings.AUTH_USER_MODEL, verbose_name='Giocatori'),
        ),
        migrations.CreateModel(
            name='MatchPlayer',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('team', models.PositiveSmallIntegerField(choices=[(1, 'Squadra 1'), (2, 'Squadra 2')])),
                ('match', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='players', to='leagues.match')),
                ('player', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='matches', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'Giocatore partita',
                'verbose_name_plural': 'Giocatori partita',
                'unique_together': {('match', 'player')},
            },
        ),
    ]


========================================
APP: crazypadel
========================================


-- crazypadel/asgi.py --

"""
ASGI config for crazypadel project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'crazypadel.settings')

application = get_asgi_application()


-- crazypadel/__init__.py --



-- crazypadel/settings.py --

import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-xyz123'  # Cambia questa chiave in produzione

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Le nostre app
    'accounts',
    'leagues',
]

# Static files
STATIC_URL = '/static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'crazypadel.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'crazypadel.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 8,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# User model personalizzato
AUTH_USER_MODEL = 'accounts.User'

# Internationalization
LANGUAGE_CODE = 'it-it'
TIME_ZONE = 'Europe/Rome'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = 'static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Auth settings
LOGIN_URL = '/accounts/login/'
LOGIN_REDIRECT_URL = '/leagues/'
LOGOUT_REDIRECT_URL = '/'

-- crazypadel/urls.py --

from django.contrib import admin
from django.urls import path, include
from django.views.generic import RedirectView

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),
    path('leagues/', include('leagues.urls')),
    path('', RedirectView.as_view(pattern_name='leagues:list', permanent=False)),
]

-- crazypadel/r.settings.py --

import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-xyz123'  # Cambia questa chiave in produzione

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = False

ALLOWED_HOSTS = ['dariovenz.pythonanywhere.com']

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Le nostre app
    'accounts',
    'leagues',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'crazypadel.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'crazypadel.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': 8,
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# User model personalizzato
AUTH_USER_MODEL = 'accounts.User'

# Internationalization
LANGUAGE_CODE = 'it-it'
TIME_ZONE = 'Europe/Rome'
USE_I18N = True
USE_TZ = True

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Auth settings
LOGIN_URL = '/accounts/login/'
LOGIN_REDIRECT_URL = '/leagues/'
LOGOUT_REDIRECT_URL = '/'

STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
STATIC_URL = '/static/'
MEDIA_URL = '/media/'

-- crazypadel/wsgi.py --

"""
WSGI config for crazypadel project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'crazypadel.settings')

application = get_wsgi_application()

